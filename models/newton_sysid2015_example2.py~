##############################################################################
##############################################################################
# Model specification
# Model for SYSID2015 paper - model 3
# Version 2014-12-03
#
# Copyright (c) 2014 Johan Dahlin [ johan.dahlin (at) liu.se ]
# Distributed under the MIT license.
#
##############################################################################
##############################################################################

#=============================================================================
# Model structure
#=============================================================================
# xtt = self.par[0] * atan( xt ) + self.par[3] * vt;
# yt  = self.par[1] * xt + self.par[2] * et;
#
# vt  ~ N(0,1)
# et  ~ N(0,1)

import numpy          as     np
from   scipy.stats    import norm
from   models_helpers import *

class ssm(object):

    #=========================================================================
    # Define model settings
    #=========================================================================
    nPar         = 4;
    par          = np.zeros(nPar);
    modelName    = "Example 2 in SYSID-paper on Newton optimisation";
    filePrefix   = "newton_sysid2015_example2";
    supportsFA   = False;
    nParInfernce = None;
    nQInference  = None;

    #=========================================================================
    # Define the model
    #=========================================================================

    def generateState(self, xt, tt):
        return self.par[0] * np.arctan( xt ) + self.par[3] * np.random.randn(1,len(xt));

    def evaluateState(self, xtt, xt, tt):
        return norm.pdf( xtt, self.par[0] * np.arctan( xt ), self.par[3] );

    def generateObservation(self, xt, tt):
        return self.par[1] * xt + self.par[2] * np.random.randn(1,len(xt));

    def evaluateObservation(self,  xt, tt):
        return norm.logpdf(self.y[tt], self.par[1] * xt, self.par[2] );

    #=========================================================================
    # Define gradients of logarithm of complete data-likelihood
    #=========================================================================
    def Dparm(self, xtt, xt, st, at, tt):

        nOut = len(xtt);
        gradient = np.zeros(( nOut, self.nParInference ));
	px = xtt - self.par[0] * np.arctan(xt);
	Q2 = self.par[3]**(-2.0)

	py = self.y[tt] - self.par[1] * xt;
	Q2 = self.par[2]**(-2.0)

        for v1 in range(0,self.nParInference):
            if v1 == 0:
                gradient[:,v1] = np.arctan(xt) * px * Q2;
            elif v1 == 1:
                gradient[:,v1] = xt * py * R2;
            else:
                gradient[:,v1] = 0.0;
        return(gradient);

    #=========================================================================
    # Define Hessians of logarithm of complete data-likelihood
    #=========================================================================
    def DDparm(self, xtt, xt, st, at, tt):
        nOut = len(xtt);
        hessian = np.zeros( (nOut, self.nParInference,self.nParInference) );
        return(hessian);

    def priorUniform(self):
        return( 0.0 );

    #=========================================================================
    # Define standard methods for the model struct
    #=========================================================================

    # Standard operations on struct
    copyData                = template_copyData;
    storeParameters         = template_storeParameters;
    returnParameters        = template_returnParameters

    # No tranformations available
    transform               = empty_transform;
    invTransform            = empty_invTransform;
    Jacobian                = empty_Jacobian;

    # Standard data generation for this model
    generateData            = template_generateData;

    # No faPF available for this model
    generateStateFA         = empty_generateStateFA;
    evaluateObservationFA   = empty_evaluateObservationFA;
    generateObservationFA   = empty_generateObservationFA;

    # No EM algorithm available for this model
    Qfunc                   = empty_Qfunc;
    Mstep                   = empty_Mstep;

    # Simple priors for this model
    prior                   = empty_prior;
    dprior1                 = empty_dprior1
    ddprior1                = empty_ddprior1
